#!/bin/bash
# shell脚本的第一行需要声明使用的shell,脚本的第一行的注释中,井号后面不需要加空格

# 版本号:0.2.1-alpha
# 版本号格式：主版本号.次版本号.修订号，版本号递增规则如下：
# 主版本号：当你做了不兼容的 API 修改,主版本号为零的软件处于开发初始阶段
# 次版本号：当你做了向下兼容的功能性新增
# 修订号：当你做了向下兼容的问题修正
# 版本号只能递增,禁止在数字前方补零,禁止使用非ASCII字符
# 增加前缀v(version)是用来表示版本号的常用做法
# 先行版本号及版本编译信息可以加到 “主版本号.次版本号.修订号” 的后面，作为延伸。例如v1.1.0-alpha0.1.0

# 功能:显示各项系统信息
# 编写日期:2022/11/2
# 编写者:俺

message='欢迎使用OS信息打印系统' 
# 1、变量的规则为var=var，等号左右不能有空格
# 2、变量值之中有的空格用引号括起来，特殊符号前加转义符
# 3、变量名只能使用英文字母，数字和下划线，首个字符不能以数字开头
# 4、用户自定义的普通变量用小写字母，不能使用bash里的关键字
echo "${message}" # echo命令可以输出内容,单引号内的内容为普通常量,双引号可以引用变量

var=$1 # $1代表输入的第一个参数 $0代表当前文件名
echo "$var" # 使用$var可以直接调用变量,$var与${var}等效,需要拼接变量时需要加上花括号
unset var # 可以使用unset var删除变量

current_directory="当前脚本工作目录是 `pwd`" # `command` 与 $(command) 等效,符号为反单引号,变量中用双引号可以引用命令或变量
home_directory="当前用户的家目录是 ${HOME}" # 变量可以等于命令执行的结果,系统变量用大写字母,系统变量不要随意设置 
echo -e "用户$(whoami)你好\n${current_directory}\n${home_directory}" #  echo -e 可以激活转义字符

[ -e /etc/redhat-release ] && echo -e '你现在使用的是红帽系Linux系统\n'|| echo -e '你现在使用的是其他系Linux系统,脚本可能会运行失败\n'
# 使用中括号代替可以代替test命令,中括号内部要保留至少一个空格
# 与运算符 && 前一个命令成功执行(返回0)则执行下一个命令,前一个命令不成功执行(返回非0)则不执行下一个命令
# 或运算符 || 前一个命令成功执行(返回0)则不执行下一个命令.前一个命令不成功执行(返回非0)则执行下一个命令

read -p '是否继续运行脚本? 输入 y 继续运行脚本,输入 CTRL+C 终止运行脚本:' input # read命令可以和用户交互,-p参数为显示提示语，且将用户输入的值存入变量input中
if [ ${input} != 'y' ];then # if  [  ];then 为固定写法不能缺,条件表达式为多个条件时，可使用运算符
	echo -e "\n输入错误 脚本将自动退出\n" 
	exit 1 # exit可以在后面加上返回值，返回值非0为失败,返回值0为成功
else # 条件不成立时候执行的命令
	printf "\n*****************************************\n" # printf命令可以直接使用转义符,使用printf命令输出后默认不会自动换行
	printf "%-12s OS信息打印系统\n" # printf命令可以制定字符串的宽度、左右对齐方式
	printf "%-13s v0.2.1-alpha \n" # %s输出一个字符串，%d整型输出，%c输出一个字符，%f输出实数
	printf "\n" # %-10s指一个宽度为10个字符(-表示左对齐，没有则表示右对齐)
	[ -e /etc/redhat-release ] && echo "    >>"$(cat /etc/redhat-release | cut -d ' ' -f 1-4)  "<<    " \
	|| printf "\n" # 使用管道符可以将第一个命令的输出成为第二个命令的输入,使用转义符可以多行书写代码
	echo ">>"$( date;date '+%D' )"<<" # 使用分号可以连续执行命令
	printf "*****************************************\n"
fi # if为开始符，fi为结束符。fi 是 if 的反写

cat <<EOF
输入1查看CPU信息
输入2查看网络信息
输入3查看内存信息
输入4查看进程信息
输入5查看磁盘信息
输入6查看用户信息
输入其他字符退出

EOF
# 0<或<将文件内容作为命令的标准输入
# 0<<或<<标识符从准输入设备输入内容，直到遇到“标识符”为止。标识符为任意字符或字符串，如end、eof等
while true 
# 1、while " 判断条件" 为固定写法不能缺
# 2、条件可以是(())、[]、[[]]和前面条件表达式判断一样
# 3、判断条件为true时循环为死循环,记得加上跳出循环的语句
do # while循环当判断条件为正确时执行下列语句
read -p '请输入需要查看的信息序号,取消运行则输入任意字符' input # 变量可以被连续赋值,上一次使用过的input变量还能被再次赋值
	case $input in # 以case开始，变量名之前加$号，写法case $var in为固定格式不可缺
	"1") # 变量的值用双括号括起来
		lscpu
		;; # 命令可以是多行,以;;结束
	"2")
		ifconfig 2>/dev/null # 如果找不到这条命令,则会输出错误信息,使用重定向符">"可以将错误消息"2"重定向至垃圾箱"null"
		# 1、符号>称为数据流重定向符
		# 2、命令返回的正确信息代码为1,可以省略,错误信息为2,不可省略
		# 3、1>或>为覆盖的方式输出(正确的信息)到指定的文件或设备上 1>>或>>为累加的方式输出(正确的信息)到文件或设备上
		command=${?} # 变量${?}为最后运行的命令的返回值,返回值为0则表示命令执行成功,否则判断命令执行失败
		if [ ${command} == 0 ];then
			echo "true" &> /dev/null # if语句下执行的语句不能留空, &>/dev/null将命令的结果(包含正确的数据和错误的数据)都输出到扔进垃圾桶(null)里
		elif [ ${command} > 0 ];then # 需要多次判断时使用多分支if语句判断,当上一次的结果判断失败时可以使用elif再次判断,写法和if语句一致
			echo -e "\n脚本找不到ifconfig命令，操作系统可能没有安装net-tools软件包"
			read -p '需要改为使用ip link命令查看吗？ (y/n) ' input
			if [ ${input} == y ];then # if语句结构中也可以嵌套if语句
				ip link
			elif [ ${input} == n ];then
				exit
			else
				echo "输入错误,脚本将退出"
				exit 1
			fi # 嵌套if语句时要注意的是，一个if要有一个fi与之对应,elif则不需要有fi对应
		fi
		;;
	"3")
		free -h
		;;
	"4")	
		top
		;;
	"5")
		lsblk
		;;
	"6")
		users=$(cut -d ":" -f 1 /etc/passwd)  #取出第一个字段（所有行：root、bin、daemon...），存入users变量中
		for username in  ${users} #循环开始，变量username为 users 第一行(root)；第二次循环，username为 users 第二行(bin)
		do # 下面是循环执行的命令
			id  ${username} # 第一次执行id root，第二次执行id bin循环到取完所有的值
		done # do结束，返回 for 继续循环
		exit
		;;
	*) # 都不等于上面的值时执行的命令
		echo "输入为其他字符,脚本将自动退出"
		exit 1
		;;
	esac # 以esac（case单词的反序书写）结束
done # while循环当判断条件为不正确时执行
